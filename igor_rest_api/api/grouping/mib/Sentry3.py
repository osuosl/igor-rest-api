# PySNMP SMI module. Autogenerated from smidump -f python Sentry3
# by libsmi2pysnmp-0.1.3 at Fri Apr  4 11:27:14 2014,
# Python version sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( Bits, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, enterprises, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "enterprises")
( DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString")

# Objects

serverTech = MibIdentifier((1, 3, 6, 1, 4, 1, 1718))
sentry3 = ModuleIdentity((1, 3, 6, 1, 4, 1, 1718, 3)).setRevisions(("2014-01-16 18:00","2013-11-25 09:00","2013-09-16 10:00","2013-02-14 09:30","2012-11-07 14:00","2012-04-18 14:00","2012-01-04 11:00","2011-07-11 16:40","2011-06-15 13:00","2011-05-05 11:00","2010-07-07 12:15","2009-03-10 16:00","2008-05-07 15:20","2007-07-09 14:45","2007-01-09 14:10","2006-07-20 12:00","2006-06-12 09:30","2005-07-27 11:05","2005-02-18 11:45","2005-01-07 12:20","2004-12-09 13:20","2004-11-11 12:00","2003-11-20 13:00","2003-10-23 19:00","2003-10-02 11:00","2003-08-27 16:00","2003-03-28 17:00","2003-03-27 17:00",))
if mibBuilder.loadTexts: sentry3.setOrganization("Server Technology, Inc.")
if mibBuilder.loadTexts: sentry3.setContactInfo("Server Technology, Inc.\n1040 Sandhill Road\nReno, NV 89521\nTel: (775) 284-2000\nFax: (775) 284-2065\nEmail: mibmaster@servertech.com")
if mibBuilder.loadTexts: sentry3.setDescription("This is the MIB module for the third generation of the\nSentry product family.  This includes the Sentry Remote\nPower Manager (RPM), Sentry Power Distribution Unit (PDU),\nSentry Environmental Monitor (EM), Sentry Smart and\nSwitched Cabinet Distribution Unit (CDU), and Sentry\nSwitched -48 VDC.")
systemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1718, 3, 1))
systemVersion = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemVersion.setDescription("The firmware version of the system.")
systemNICSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemNICSerialNumber.setDescription("The serial number of the network interface card in the\nsystem.")
systemLocation = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemLocation.setDescription("The location of the system.")
systemTowerCount = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemTowerCount.setDescription("The number of towers in the system.")
systemEnvMonCount = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemEnvMonCount.setDescription("The number of environmental monitors in the system.")
systemTotalPower = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 150000))).setMaxAccess("readonly").setUnits("Watts")
if mibBuilder.loadTexts: systemTotalPower.setDescription("The total power consumption of all of the input feeds in the\nsystem.  A non-negative value indicates the total power\nconsumption in Watts.  A negative value indicates that the\ntotal power consumption was not available.")
systemArea = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite").setUnits("tenth area units")
if mibBuilder.loadTexts: systemArea.setDescription("The area that the footprint of the system occupies.  A\nnon-zero non-negative value indicates the area in tenths of\narea units as selected by the systemAreaUnit object.  A zero\nor negative value indicates that the area was not available.")
systemWattsPerAreaUnit = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1500000))).setMaxAccess("readonly").setUnits("Watts per area unit")
if mibBuilder.loadTexts: systemWattsPerAreaUnit.setDescription("The system Watts per area unit.  A non-negative value\nindicates the power consumption per area unit as selected by\nthe systemAreaUnit object.  A negative value indicates that\nthe power consumption per area unit was not available.")
systemAreaUnit = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("squareMeter", 0), ("squareFoot", 1), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemAreaUnit.setDescription("The unit of area for the systemArea and systemWattsPerAreaUnit\nobjects.  If the agent does not support this object, then the\nunit of area is a square foot.")
systemPowerFactor = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 100))).setMaxAccess("readwrite").setUnits("hundredths")
if mibBuilder.loadTexts: systemPowerFactor.setDescription("The power factor used in power calculations performed by the\nsystem.")
systemFeatures = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 11), Bits().subtype(namedValues=NamedValues(("smartLoadShedding", 0), ("snmpPOPS", 1), ("outletControlInhibit", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFeatures.setDescription("The key-activated features enabled in the system.")
systemFeatureKey = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemFeatureKey.setDescription("A valid feature key written to this object will enable a\nfeature in the system.  A valid feature key is in the form\nxxxx-xxxx-xxxx-xxxx.  A read of this object returns an\nempty string.")
systemOutletSeqInterval = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: systemOutletSeqInterval.setDescription("The power-on sequencing interval for all outlets.")
systemOutletRebootDelay = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 600))).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: systemOutletRebootDelay.setDescription("The reboot delay for all outlets.")
systemConfigModifiedCount = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemConfigModifiedCount.setDescription("The total number of times the system configuration has\nchanged.")
systemTables = MibIdentifier((1, 3, 6, 1, 4, 1, 1718, 3, 2))
towerTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1))
if mibBuilder.loadTexts: towerTable.setDescription("A table of towers.")
towerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1)).setIndexNames((0, "Sentry3", "towerIndex"))
if mibBuilder.loadTexts: towerEntry.setDescription("Row definition for the tower table.")
towerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: towerIndex.setDescription("Index for the tower table.")
towerID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerID.setDescription("The ID of the tower.")
towerName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: towerName.setDescription("The name of the tower.")
towerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,3,1,5,2,4,)).subtype(namedValues=NamedValues(("normal", 0), ("noComm", 1), ("fanFail", 2), ("overTemp", 3), ("nvmFail", 4), ("outOfBalance", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerStatus.setDescription("The operational status of the tower.")
towerInfeedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerInfeedCount.setDescription("The number of input feeds on the tower.")
towerProductSN = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerProductSN.setDescription("The product serial number of the tower.")
towerModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerModelNumber.setDescription("The model number of the tower.")
towerCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 8), Bits().subtype(namedValues=NamedValues(("failSafe", 0), ("fuseSense", 1), ("directCurrent", 2), ("threePhase", 3), ("fanSense", 4), ("tempSense", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerCapabilities.setDescription("The capabilities of the tower.")
towerVACapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerVACapacity.setDescription("The total apparent power capacity of the tower circuit.\nA non-negative value indicates the maximum total apparent\npower in Volt-Amps.  A negative value indicates that the\ntotal apparent power capacity was not available.")
towerVACapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerVACapacityUsed.setDescription("The used percentage of the tower circuit total apparent power\ncapacity (towerApparentPower / towerVACapacity x 100).  A\nnon-negative value indicates the percentage of capacity used\nin tenths.  A negative value indicates that the percentage of\ncapacity used was not available.")
towerActivePower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerActivePower.setDescription("The total active power consumption of the tower circuit.\nA non-negative value indicates the total active power\nconsumption in Watts.  A negative value indicates that the\ntotal active power consumption was not available.")
towerApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerApparentPower.setDescription("The total apparent power consumption of the tower circuit.\nA non-negative value indicates the total apparent power\nconsumption in Volt-Amps.  A negative value indicates that\nthe total apparent power consumption was not available.")
towerPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerPowerFactor.setDescription("The overall power factor of the tower circuit.  A non-\nnegative value indicates the overall power factor in\nhundredths.  A negative value indicates that the overall\npower factor was not able to be measured.")
towerEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerEnergy.setDescription("The total energy consumption of the tower circuit.  A non-\nnegative value indicates the total energy consumption in\nKilowatt-Hours.  A negative value indicates that the total\nenergy consumption was not available.")
towerLineFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: towerLineFrequency.setDescription("The frequency of the input feed line voltage.  A non-\nnegative value indicates the frequency in Hertz.  A negative\nvalue indicates that the frequency was not available.")
infeedTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2))
if mibBuilder.loadTexts: infeedTable.setDescription("A table of input feeds.")
infeedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1)).setIndexNames((0, "Sentry3", "towerIndex"), (0, "Sentry3", "infeedIndex"))
if mibBuilder.loadTexts: infeedEntry.setDescription("Row definition for the input feed table.")
infeedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: infeedIndex.setDescription("Index for the input feed table.")
infeedID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedID.setDescription("The ID of the input feed.")
infeedName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: infeedName.setDescription("The name of the input feed.")
infeedCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 4), Bits().subtype(namedValues=NamedValues(("onSense", 0), ("loadSense", 1), ("powerControl", 2), ("failSafe", 3), ("defaultOff", 4), ("voltageSense", 5), ("powerSense", 6), ("branchOnSense", 7), ("branchLoadSense", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedCapabilities.setDescription("The capabilities of the input feed.")
infeedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(4,8,3,1,0,2,5,6,9,7,)).subtype(namedValues=NamedValues(("off", 0), ("on", 1), ("offWait", 2), ("onWait", 3), ("offError", 4), ("onError", 5), ("noComm", 6), ("reading", 7), ("offFuse", 8), ("onFuse", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedStatus.setDescription("The status of the input feed line.  If the infeedCapabilities\n'onSense' bit is TRUE, then all of the states are supported\nand indicate the sensed state of the input feed.  If the\ninfeedCapabilities 'onSense' bit is FALSE, then only the\n'on' and 'noComm' states are supported, and 'on' indicates\na derived state, not a sensed state.")
infeedLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,7,0,3,5,6,)).subtype(namedValues=NamedValues(("normal", 0), ("notOn", 1), ("reading", 2), ("loadLow", 3), ("loadHigh", 4), ("overLoad", 5), ("readError", 6), ("noComm", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedLoadStatus.setDescription("The status of the load measured on the input feed line.  If\nthe infeedCapabilities 'loadSense' bit is TRUE, then all of\nthe states are supported.  If the infeedCapabilities\n'loadSense' bit is FALSE, then only the 'normal' and 'noComm'\nstates are supported.")
infeedLoadValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedLoadValue.setDescription("The load measured on the input feed line.  A non-negative\nvalue indicates the measured load in hundredths of Amps.  A\nnegative value indicates that a load value was not able to\nbe measured.")
infeedLoadHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: infeedLoadHighThresh.setDescription("The load high threshold value of the input feed line in Amps.")
infeedOutletCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedOutletCount.setDescription("The number of controlled and/or monitored outlets on the\ninput feed.")
infeedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedCapacity.setDescription("The load capacity of the input feed line.  A non-negative\nvalue indicates the maximum load in Amps.  A negative\nvalue indicates that the capacity was not available.")
infeedVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedVoltage.setDescription("The line-to-line voltage of the input feed.  A non-negative\nvalue indicates the voltage in tenths of Volts.  A negative\nvalue indicates that the voltage was not available.")
infeedPower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 25000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedPower.setDescription("The active power consumption of the input feed phase.  A non-\nnegative value indicates the active power consumption in\nWatts.  A negative value indicates that the active power\nconsumption was not available.")
infeedApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 25000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedApparentPower.setDescription("The apparent power consumption of the input feed phase.  A\nnon-negative value indicates the apparent power consumption\nin Volt-Amps.  A negative value indicates that the apparent\npower consumption was not available.")
infeedPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedPowerFactor.setDescription("The power factor of the input feed phase.  A non-negative\nvalue indicates the power factor in hundredths.  A negative\nvalue indicates that the power factor was not able to be\nmeasured.")
infeedCrestFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedCrestFactor.setDescription("The crest factor for the load of the input feed phase.  A\nnon-negative value indicates the crest factor in tenths.  A\nnegative value indicates that the crest factor was not able\nto be measured.")
infeedEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedEnergy.setDescription("The energy consumption of the input feed phase.  A non-\nnegative value indicates the energy consumption in tenths of\nKilowatt-Hours.  A negative value indicates that the energy\nconsumption was not available.")
infeedReactance = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(0,3,2,1,)).subtype(namedValues=NamedValues(("unknown", 0), ("capacitive", 1), ("inductive", 2), ("resistive", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedReactance.setDescription("The characterization of the phase relation between the\nvoltage and current of the input feed phase.")
infeedPhaseVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2640))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedPhaseVoltage.setDescription("The voltage measured for the input feed phase.  A non-\nnegative value indicates the voltage in tenths of Volts.  A\nnegative value indicates that the voltage was not available.")
infeedPhaseCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 25500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedPhaseCurrent.setDescription("The current measured for the input feed phase.  A non-\nnegative value indicates the measured load in hundredths of\nAmps.  A negative value indicates that a load value was not\nable to be measured.")
infeedCapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedCapacityUsed.setDescription("The used percentage of the input feed line load capacity\n(infeedLoadValue / infeedCapacity x 100).  A non-negative\nvalue indicates the percentage of capacity used in tenths.\nA negative value indicates that the percentage of capacity\nused was not available.")
infeedLineID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedLineID.setDescription("The ID of the input feed line.")
infeedLineToLineID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedLineToLineID.setDescription("The line-to-line ID of the input feed.")
infeedPhaseID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedPhaseID.setDescription("The ID of the input feed phase.")
infeedVACapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 25000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedVACapacity.setDescription("The apparent power capacity of the input feed circuit.  A\nnon-negative value indicates the maximum apparent power in\nVolt-Amps.  A negative value indicates that the apparent\npower capacity was not available.")
infeedVACapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infeedVACapacityUsed.setDescription("The used percentage of the input feed circuit apparent power\ncapacity (infeedApparentPower / infeedVACapacity x 100).  A\nnon-negative value indicates the percentage of capacity used\nin tenths.  A negative value indicates that the percentage of\ncapacity used was not available.")
outletTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3))
if mibBuilder.loadTexts: outletTable.setDescription("A table of outlets.")
outletEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1)).setIndexNames((0, "Sentry3", "towerIndex"), (0, "Sentry3", "infeedIndex"), (0, "Sentry3", "outletIndex"))
if mibBuilder.loadTexts: outletEntry.setDescription("Row definition for the outlet table.")
outletIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: outletIndex.setDescription("Index for the outlet table.")
outletID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletID.setDescription("The ID of the outlet.")
outletName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletName.setDescription("The name of the outlet.")
outletCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 4), Bits().subtype(namedValues=NamedValues(("onSense", 0), ("loadSense", 1), ("powerControl", 2), ("shutdown", 3), ("defaultOn", 4), ("ownInfeed", 5), ("fusedBranch", 6), ("voltageSense", 7), ("powerSense", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletCapabilities.setDescription("The capabilities of the outlet.")
outletStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(4,8,3,1,0,2,5,6,9,7,)).subtype(namedValues=NamedValues(("off", 0), ("on", 1), ("offWait", 2), ("onWait", 3), ("offError", 4), ("onError", 5), ("noComm", 6), ("reading", 7), ("offFuse", 8), ("onFuse", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletStatus.setDescription("The status of the outlet.  If the outletCapabilities\n'onSense' bit is TRUE, then the state indicates the sensed\nstate of the outlet, not a derived state, and 'offError'\nand 'onError' are supported to indicate a mismatch between\nthe control and sensed state.  If the outletCapabilities\n'fusedBranch' bit is TRUE, then the outlet is on a fused\nbranch circuit that can detect the fuse state, and 'offFuse'\nand 'onFuse' are supported to indicate a fuse error.")
outletLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,7,0,3,5,6,)).subtype(namedValues=NamedValues(("normal", 0), ("notOn", 1), ("reading", 2), ("loadLow", 3), ("loadHigh", 4), ("overLoad", 5), ("readError", 6), ("noComm", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletLoadStatus.setDescription("The status of the load measured on the outlet.  If the \noutletCapabilities 'loadSense' bit is TRUE, then all of the\nstates are supported.  If the outletCapabilities 'loadSense'\nbit is FALSE, then only the 'normal' and 'noComm' states are\nsupported.")
outletLoadValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 25500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletLoadValue.setDescription("The load measured on the outlet.  A non-negative value\nindicates the measured load in hundredths of Amps.  A\nnegative value indicates that a load value was not able to\nbe measured.")
outletLoadLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletLoadLowThresh.setDescription("The load low threshold value of the outlet in Amps.")
outletLoadHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletLoadHighThresh.setDescription("The load high threshold value of the outlet in Amps.")
outletControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(5,0,4,10,16,11,17,8,1,2,12,3,9,14,6,15,7,13,)).subtype(namedValues=NamedValues(("idleOff", 0), ("idleOn", 1), ("pendOn", 10), ("pendOff", 11), ("minimumOff", 12), ("minimumOn", 13), ("eventOff", 14), ("eventOn", 15), ("eventReboot", 16), ("eventShutdown", 17), ("wakeOff", 2), ("wakeOn", 3), ("off", 4), ("on", 5), ("lockedOff", 6), ("lockedOn", 7), ("reboot", 8), ("shutdown", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletControlState.setDescription("The control state of the outlet.  The supported states are\ndependent upon the outletCapabilities 'powerControl' and\n'shutdown' bits, as well as the supported features of the\nfirmware version.")
outletControlAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,3,)).subtype(namedValues=NamedValues(("none", 0), ("on", 1), ("off", 2), ("reboot", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletControlAction.setDescription("An action to change the control state of the outlet.  If\nthe outletCapabilities 'powerControl' bit is TRUE, then the\n'on', 'off', and 'reboot' actions can be used to change the\ncontrol state of the outlet.  If the outletCapabilities\n'powerControl' bit is FALSE, then the actions have no\neffect.")
outletCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletCapacity.setDescription("The load capacity of the outlet.  A non-negative value\nindicates the maximum load in Amps.  A negative value\nindicates that the capacity was not available.")
outletVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2640))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletVoltage.setDescription("The voltage of the outlet.  A non-negative value indicates\nthe voltage in tenths of Volts.  A negative value indicates\nthat the voltage was not available.")
outletPower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletPower.setDescription("The active power consumption of the device plugged into the\noutlet.  A non-negative value indicates the active power\nconsumption in Watts.  A negative value indicates that the\nactive power consumption was not available.")
outletApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletApparentPower.setDescription("The apparent power consumption of the device plugged into\nthe outlet.  A non-negative value indicates the apparent\npower consumption in Volt-Amps.  A negative value indicates\nthat the apparent power consumption was not available.")
outletPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletPowerFactor.setDescription("The power factor of the device plugged into the outlet.  A\nnon-negative value indicates the power factor in hundredths.\nA negative value indicates that the power factor was not able\nto be measured.")
outletCrestFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletCrestFactor.setDescription("The crest factor for the load of the device plugged into the\noutlet.  A non-negative value indicates the crest factor in\ntenths.  A negative value indicates that the crest factor\nwas not able to be measured.")
outletEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outletEnergy.setDescription("The energy consumption of the device plugged into the outlet.\nA non-negative value indicates the energy consumption in\nWatt-Hours.  A negative value indicates that the energy\nconsumption was not available.")
outletWakeupState = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 19), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("last", 1), ("off", 2), ("on", 3), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletWakeupState.setDescription("The wakeup state of the outlet.")
outletPostOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: outletPostOnDelay.setDescription("The post-on delay of the outlet.")
envMonTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4))
if mibBuilder.loadTexts: envMonTable.setDescription("A table of environmental monitors.")
envMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1)).setIndexNames((0, "Sentry3", "envMonIndex"))
if mibBuilder.loadTexts: envMonEntry.setDescription("Row definition for the environmental monitor table.")
envMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: envMonIndex.setDescription("Index for the environmental monitor table.")
envMonID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonID.setDescription("The ID of the environmental monitor.")
envMonName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envMonName.setDescription("The name of the environmental monitor.")
envMonStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("normal", 0), ("noComm", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonStatus.setDescription("The operational status of the environmental monitor.")
envMonWaterSensorName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envMonWaterSensorName.setDescription("The name of the water sensor.")
envMonWaterSensorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,)).subtype(namedValues=NamedValues(("normal", 0), ("alarm", 1), ("noComm", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonWaterSensorStatus.setDescription("The status of the water sensor.")
envMonADCName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envMonADCName.setDescription("The name of the analog-to-digital converter.")
envMonADCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(0,2,5,3,1,4,)).subtype(namedValues=NamedValues(("normal", 0), ("reading", 1), ("countLow", 2), ("countHigh", 3), ("readError", 4), ("noComm", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonADCStatus.setDescription("The status of the analog-to-digital converter.")
envMonADCCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonADCCount.setDescription("The 8-bit count value from the analog-to-digital converter.\nA non-negative value indicates the digital value retrieved\nfrom the ADC.  A negative value indicates that a digital\nvalue was not able to be retrieved.")
envMonADCLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envMonADCLowThresh.setDescription("The 8-bit count low threshold value of the analog-to-digital\nconverter.")
envMonADCHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: envMonADCHighThresh.setDescription("The 8-bit count high threshold value of the analog-to-digital\nconverter.")
envMonTempHumidSensorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonTempHumidSensorCount.setDescription("The number of temperature/humidity sensors on the\nenvironmental monitor.")
envMonContactClosureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: envMonContactClosureCount.setDescription("The number of contact closures on the environmental\nmonitor.")
tempHumidSensorTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5))
if mibBuilder.loadTexts: tempHumidSensorTable.setDescription("A table of temperature/humidity sensors.")
tempHumidSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1)).setIndexNames((0, "Sentry3", "envMonIndex"), (0, "Sentry3", "tempHumidSensorIndex"))
if mibBuilder.loadTexts: tempHumidSensorEntry.setDescription("Row definition for the temperature/humidity sensor table.")
tempHumidSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: tempHumidSensorIndex.setDescription("Index for the temperature/humidity sensor table.")
tempHumidSensorID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorID.setDescription("The ID of the temperature/humidity sensor.")
tempHumidSensorName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorName.setDescription("The name of the temperature/humidity sensor.")
tempHumidSensorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,3,2,1,)).subtype(namedValues=NamedValues(("found", 0), ("notFound", 1), ("lost", 2), ("noComm", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorStatus.setDescription("The operational status of the temperature/humidity sensor.")
tempHumidSensorTempStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,6,4,0,7,5,)).subtype(namedValues=NamedValues(("normal", 0), ("notFound", 1), ("reading", 2), ("tempLow", 3), ("tempHigh", 4), ("readError", 5), ("lost", 6), ("noComm", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorTempStatus.setDescription("The status of the temperature sensor.")
tempHumidSensorTempValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2540))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorTempValue.setDescription("The temperature measured by the sensor.  A non-negative value\nindicates the measured temperature in tenths of degrees, using\nthe scale selected by tempHumidSensorTempScale.  If the agent\ndoes not support the tempHumidSensorTempScale object, then the\ntemperature scale used is Celsius.  A negative value indicates\nthat a temperature value was not able to be measured.")
tempHumidSensorTempLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorTempLowThresh.setDescription("The temperature low threshold value of the sensor in degrees,\nusing the scale selected by tempHumidSensorTempScale.  If the\nagent does not support the tempHumidSensorTempScale object,\nthen the temperature scale used is Celsius.")
tempHumidSensorTempHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorTempHighThresh.setDescription("The temperature high threshold value of the sensor in degrees,\nusing the scale selected by tempHumidSensorTempScale.  If the\nagent does not support the tempHumidSensorTempScale object,\nthen the temperature scale used is Celsius.")
tempHumidSensorHumidStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,6,3,0,4,7,5,)).subtype(namedValues=NamedValues(("normal", 0), ("notFound", 1), ("reading", 2), ("humidLow", 3), ("humidHigh", 4), ("readError", 5), ("lost", 6), ("noComm", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorHumidStatus.setDescription("The status of the humidity sensor.")
tempHumidSensorHumidValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempHumidSensorHumidValue.setDescription("The humidity measured by the sensor.  A non-negative value\nindicates the measured humidity in percentage relative\nhumidity.  A negative value indicates that a humidity value\nwas not able to be measured.")
tempHumidSensorHumidLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorHumidLowThresh.setDescription("The humidity low threshold value of the sensor in percentage\nrelative humidity.")
tempHumidSensorHumidHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorHumidHighThresh.setDescription("The humidity low threshold value of the sensor in percentage\nrelative humidity.")
tempHumidSensorTempScale = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("celsius", 0), ("fahrenheit", 1), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorTempScale.setDescription("The scale used for temperature values.  This is a global\nsetting for all temperature values in the system.  If the\nagent does not support this object, then the temperature\nscale used is Celsius.")
tempHumidSensorTempRecDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorTempRecDelta.setDescription("The temperature recovery delta (hysteresis) value of the\nsensor in degrees, using the scale selected by\ntempHumidSensorTempScale.")
tempHumidSensorHumidRecDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tempHumidSensorHumidRecDelta.setDescription("The humidity recovery delta (hysteresis) value of the\nsensor in percentage relative humidity.")
contactClosureTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6))
if mibBuilder.loadTexts: contactClosureTable.setDescription("A table of contact closures.")
contactClosureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6, 1)).setIndexNames((0, "Sentry3", "envMonIndex"), (0, "Sentry3", "contactClosureIndex"))
if mibBuilder.loadTexts: contactClosureEntry.setDescription("Row definition for the contact closure table.")
contactClosureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: contactClosureIndex.setDescription("Index for the contact closure table.")
contactClosureID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: contactClosureID.setDescription("The ID of the contact closure.")
contactClosureName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: contactClosureName.setDescription("The name of the contact closure.")
contactClosureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 6, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,)).subtype(namedValues=NamedValues(("normal", 0), ("alarm", 1), ("noComm", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: contactClosureStatus.setDescription("The status of the contact closure.")
branchTable = MibTable((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7))
if mibBuilder.loadTexts: branchTable.setDescription("A table of branches.")
branchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1)).setIndexNames((0, "Sentry3", "towerIndex"), (0, "Sentry3", "infeedIndex"), (0, "Sentry3", "branchIndex"))
if mibBuilder.loadTexts: branchEntry.setDescription("Row definition for the branch table.")
branchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: branchIndex.setDescription("Index for the branch table.")
branchID = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchID.setDescription("The ID of the branch.")
branchName = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: branchName.setDescription("The name of the branch.")
branchCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 4), Bits().subtype(namedValues=NamedValues(("onSense", 0), ("loadSense", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchCapabilities.setDescription("The capabilities of the branch.")
branchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(4,8,3,1,0,2,5,6,9,7,)).subtype(namedValues=NamedValues(("off", 0), ("on", 1), ("offWait", 2), ("onWait", 3), ("offError", 4), ("onError", 5), ("noComm", 6), ("reading", 7), ("offFuse", 8), ("onFuse", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchStatus.setDescription("The status of the branch.")
branchLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,7,0,3,5,6,)).subtype(namedValues=NamedValues(("normal", 0), ("notOn", 1), ("reading", 2), ("loadLow", 3), ("loadHigh", 4), ("overLoad", 5), ("readError", 6), ("noComm", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchLoadStatus.setDescription("The status of the load measured on the branch.")
branchLoadValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchLoadValue.setDescription("The load measured on the branch.  A non-negative\nvalue indicates the measured load in hundredths of Amps.  A\nnegative value indicates that a load value was not able to\nbe measured.")
branchLoadHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: branchLoadHighThresh.setDescription("The load high threshold value of the branch in Amps.")
branchCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 1718, 3, 2, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: branchCapacity.setDescription("The load capacity of the branch.  A non-negative value\nindicates the maximum load in Amps.  A negative value\nindicates that the capacity was not available.")
eventInformationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1718, 3, 99))
eventStatusText = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 99, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventStatusText.setDescription("The text representation of the enumerated integer value of\nthe status object included in a trap.  The value of this\nobject is set only when sent with a trap.  A get of this\nobject will return a NULL string.")
eventStatusCondition = MibScalar((1, 3, 6, 1, 4, 1, 1718, 3, 99, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("nonError", 0), ("error", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventStatusCondition.setDescription("The condition of the enumerated integer value of the status\nobject included in a trap.  The value of this object is set\nonly when sent with a trap.  A get of this object will\nreturn zero.")
sentry3Traps = MibIdentifier((1, 3, 6, 1, 4, 1, 1718, 3, 100))
events = MibIdentifier((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0))

# Augmentions

# Notifications

towerStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 1)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "towerName"), ("Sentry3", "eventStatusText"), ("Sentry3", "towerStatus"), ("Sentry3", "towerID"), ) )
if mibBuilder.loadTexts: towerStatusEvent.setDescription("Tower status event.  If enabled, this trap is sent when the\ntowerStatus indicates an error state ('noComm', 'fanFail',\n'overTemp', 'nvmFail', or 'outOfBalance').  This trap is\nrepeated periodically while the towerStatus remains in an\nerror state.  If the towerStatus returns to a non-error\nstate ('normal'), this trap is sent once more with the\nnon-error towerStatus, and then stops being repeated.\n\nWhile the towerStatus indicates a 'noComm' error state, all\nstatus and load traps are suppressed for input feeds and\noutlets on the tower.")
infeedStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 2)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "infeedName"), ("Sentry3", "infeedStatus"), ("Sentry3", "infeedID"), ) )
if mibBuilder.loadTexts: infeedStatusEvent.setDescription("Input feed status event.  If enabled, this trap is sent when\nthe infeedStatus indicates an error state ('offError',\n'onError', 'noComm', 'offFuse', or 'onFuse').  This trap is\nrepeated periodically while the infeedStatus remains in an\nerror state.  If the infeedStatus returns to a non-error\nstate ('off' or 'on'), this trap is sent once more with the\nnon-error infeedStatus, and then stops being repeated.\n\nWhile the infeedStatus indicates an error state, load\ntraps are suppressed for the input feed, and, if the\ninfeedCapabilities 'failSafe' bit is FALSE, all status and\nload traps are suppressed for outlets on the input feed.")
infeedLoadEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 3)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "infeedLoadValue"), ("Sentry3", "infeedID"), ("Sentry3", "infeedLoadHighThresh"), ("Sentry3", "infeedName"), ("Sentry3", "infeedLoadStatus"), ) )
if mibBuilder.loadTexts: infeedLoadEvent.setDescription("Input feed load event.  If enabled, this trap is sent when\nthe infeedLoadStatus indicates an error state ('loadLow',\n'loadHigh', 'overLoad', 'readError', or 'noComm').  This\ntrap is repeated periodically while the infeedLoadStatus\nremains in an error state.  If the infeedLoadStatus returns\nto a non-error state ('normal' or 'notOn'), this trap is\nsent once more with the non-error infeedLoadStatus, and then\nstops being repeated.")
outletStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 4)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "outletName"), ("Sentry3", "outletStatus"), ("Sentry3", "outletID"), ) )
if mibBuilder.loadTexts: outletStatusEvent.setDescription("Outlet status event.  If enabled, this trap is sent when the\noutletStatus indicates an error state ('offError', 'onError',\n'noComm', 'offFuse', or 'onFuse').  This trap is repeated\nperiodically while the outletStatus remains in an error state.\nIf the outletStatus returns to a non-error state ('off' or\n'on'), this trap is sent once more with the non-error\noutletStatus, and then stops being repeated.\n\nWhile the outletStatus indicates an error state, load traps\nare suppressed for the outlet.")
outletLoadEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 5)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "outletLoadValue"), ("Sentry3", "outletLoadLowThresh"), ("Sentry3", "eventStatusText"), ("Sentry3", "outletLoadStatus"), ("Sentry3", "outletLoadHighThresh"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "outletName"), ("Sentry3", "outletID"), ) )
if mibBuilder.loadTexts: outletLoadEvent.setDescription("Outlet load event.  If enabled, this trap is sent when the\noutletLoadStatus indicates an error state ('loadLow',\n'loadHigh', 'overLoad', 'readError', or 'noComm').  This\ntrap is repeated periodically while the outletLoadStatus\nremains in an error state.  If the outletLoadStatus returns\nto a non-error state ('normal' or 'notOn'), this trap is\nsent once more with the non-error outletLoadStatus, and then\nstops being repeated.")
outletChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 6)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "outletName"), ("Sentry3", "outletStatus"), ("Sentry3", "outletID"), ("Sentry3", "outletControlState"), ) )
if mibBuilder.loadTexts: outletChangeEvent.setDescription("Outlet on/off change event.  If enabled, this trap is sent\nwhen the outletStatus changes from any 'on' state ('on',\n'onWait', 'onError', or 'onFuse') to any 'off' state ('off',\n'offWait', 'offError', or 'offFuse'), and vice-versa.")
envMonStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 7)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "envMonName"), ("Sentry3", "envMonStatus"), ("Sentry3", "envMonID"), ) )
if mibBuilder.loadTexts: envMonStatusEvent.setDescription("Environmental monitor status event.  If enabled, this trap\nis sent when the envMonStatus indicates an error state\n('noComm').  This trap is repeated periodically while the\nenvMonStatus remains in an error state.  If the envMonStatus\nreturns to a non-error state ('normal'), this trap is sent\nonce more with the non-error envMonStatus, and then stops\nbeing repeated.\n\nWhile the envMonStatus indicates an error state, all status\ntraps are suppressed for the water sensor, ADC, temperature/\nhumidity sensors, and contact closures on the environmental\nmonitor.")
envMonWaterSensorEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 8)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "envMonWaterSensorStatus"), ("Sentry3", "envMonWaterSensorName"), ("Sentry3", "envMonID"), ) )
if mibBuilder.loadTexts: envMonWaterSensorEvent.setDescription("Environmental monitor water sensor event.  If enabled, this\ntrap is sent when the envMonWaterSensorStatus indicates an\nerror state ('alarm').  This trap is repeated periodically\nwhile the envMonWaterSensorStatus remains in an error state.\nIf the envMonWaterSensorStatus returns to a non-error state\n('normal'), this trap is sent once more with the non-error\nenvMonWaterSensorStatus, and then stops being repeated.")
envMonADCEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 9)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "envMonADCStatus"), ("Sentry3", "eventStatusText"), ("Sentry3", "envMonADCLowThresh"), ("Sentry3", "envMonADCCount"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "envMonADCHighThresh"), ("Sentry3", "envMonADCName"), ("Sentry3", "envMonID"), ) )
if mibBuilder.loadTexts: envMonADCEvent.setDescription("Environmental monitor analog-to-digital converter event.\nIf enabled, this trap is sent when the envMonADCStatus\nindicates an error state ('countLow' or 'countHigh').  This\ntrap is repeated periodically while the envMonADCStatus\nremains in an error state.  If the envMonADCStatus returns\nto a non-error state ('normal'), this trap is sent once more\nwith the non-error envMonADCStatus, and then stops being\nrepeated.")
tempHumidSensorStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 10)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "tempHumidSensorStatus"), ("Sentry3", "tempHumidSensorName"), ("Sentry3", "eventStatusText"), ("Sentry3", "tempHumidSensorID"), ) )
if mibBuilder.loadTexts: tempHumidSensorStatusEvent.setDescription("Temperature/humidity sensor status event.  If enabled, this\ntrap is sent when the tempHumidSensorStatus indicates an\nerror state ('lost').  This trap is repeated periodically\nwhile the tempHumidSensorStatus remains in an error state.\nIf the tempHumidSensorStatus returns to a non-error state\n('found'), this trap is sent once more with the non-error\ntempHumidSensorStatus, and then stops being repeated.\n\nWhile the tempHumidSensorStatus indicates an error state, all\ntemperature and humidity status traps are suppressed for the\ntemperature/humidity sensor.")
tempHumidSensorTempEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 11)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "tempHumidSensorName"), ("Sentry3", "eventStatusText"), ("Sentry3", "tempHumidSensorTempValue"), ("Sentry3", "tempHumidSensorTempHighThresh"), ("Sentry3", "tempHumidSensorTempScale"), ("Sentry3", "tempHumidSensorID"), ("Sentry3", "tempHumidSensorTempStatus"), ("Sentry3", "tempHumidSensorTempLowThresh"), ) )
if mibBuilder.loadTexts: tempHumidSensorTempEvent.setDescription("Temperature/humidity sensor temperature event.  If enabled,\nthis trap is sent when the tempHumidSensorTempStatus\nindicates an error state ('tempLow' or 'tempHigh').\nThis trap is repeated periodically while the\ntempHumidSensorTempStatus remains in an error state.  If\nthe tempHumidSensorTempStatus returns to a non-error state\n('normal'), this trap is sent once more with the non-error\ntempHumidSensorTempStatus, and then stops being repeated.")
tempHumidSensorHumidEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 12)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "tempHumidSensorHumidHighThresh"), ("Sentry3", "tempHumidSensorName"), ("Sentry3", "eventStatusText"), ("Sentry3", "tempHumidSensorHumidLowThresh"), ("Sentry3", "tempHumidSensorHumidStatus"), ("Sentry3", "tempHumidSensorID"), ("Sentry3", "tempHumidSensorHumidValue"), ) )
if mibBuilder.loadTexts: tempHumidSensorHumidEvent.setDescription("Temperature/humidity sensor humidity event.  If enabled,\nthis trap is sent when the tempHumidSensorHumidStatus\nindicates an error state ('humidLow' or 'humidHigh').\nThis trap is repeated periodically while the\ntempHumidSensorHumidStatus remains in an error state.  If\nthe tempHumidSensorHumidStatus returns to a non-error state\n('normal'), this trap is sent once more with the non-error\ntempHumidSensorHumidStatus, and then stops being repeated.")
contactClosureEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 13)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "contactClosureStatus"), ("Sentry3", "contactClosureName"), ("Sentry3", "contactClosureID"), ) )
if mibBuilder.loadTexts: contactClosureEvent.setDescription("Contact closure event.  If enabled, this trap is sent when\nthe contactClosureStatus indicates an error state ('alarm').\nThis trap is repeated periodically while the\ncontactClosureStatus remains in an error state.  If the\ncontactClosureStatus returns to a non-error state ('normal'),\nthis trap is sent once more with the non-error\ncontactClosureStatus, and then stops being repeated.")
branchStatusEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 14)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "eventStatusText"), ("Sentry3", "branchID"), ("Sentry3", "branchStatus"), ("Sentry3", "branchName"), ) )
if mibBuilder.loadTexts: branchStatusEvent.setDescription("Branch status event.  If enabled, this trap is sent when\nthe branchStatus indicates an error state ('offError',\n'onError', 'noComm', 'offFuse', or 'onFuse').  This trap\nis repeated periodically while the branchStatus remains in\nan error state.  If the branchStatus returns to a non-error\nstate ('off' or 'on'), this trap is sent once more with the\nnon-error branchStatus, and then stops being repeated.\n\nWhile the branchStatus indicates an error state, load traps\nare suppressed for the branch.")
branchLoadEvent = NotificationType((1, 3, 6, 1, 4, 1, 1718, 3, 100, 0, 15)).setObjects(*(("Sentry3", "systemLocation"), ("Sentry3", "eventStatusCondition"), ("Sentry3", "branchLoadStatus"), ("Sentry3", "eventStatusText"), ("Sentry3", "branchLoadHighThresh"), ("Sentry3", "branchID"), ("Sentry3", "branchLoadValue"), ("Sentry3", "branchName"), ) )
if mibBuilder.loadTexts: branchLoadEvent.setDescription("Branch load event.  If enabled, this trap is sent when\nthe branchLoadStatus indicates an error state ('loadLow',\n'loadHigh', 'overLoad', 'readError', or 'noComm').  This\ntrap is repeated periodically while the branchLoadStatus\nremains in an error state.  If the branchLoadStatus returns\nto a non-error state ('normal' or 'notOn'), this trap is\nsent once more with the non-error branchLoadStatus, and then\nstops being repeated.")

# Exports

# Module identity
mibBuilder.exportSymbols("Sentry3", PYSNMP_MODULE_ID=sentry3)

# Objects
mibBuilder.exportSymbols("Sentry3", serverTech=serverTech, sentry3=sentry3, systemGroup=systemGroup, systemVersion=systemVersion, systemNICSerialNumber=systemNICSerialNumber, systemLocation=systemLocation, systemTowerCount=systemTowerCount, systemEnvMonCount=systemEnvMonCount, systemTotalPower=systemTotalPower, systemArea=systemArea, systemWattsPerAreaUnit=systemWattsPerAreaUnit, systemAreaUnit=systemAreaUnit, systemPowerFactor=systemPowerFactor, systemFeatures=systemFeatures, systemFeatureKey=systemFeatureKey, systemOutletSeqInterval=systemOutletSeqInterval, systemOutletRebootDelay=systemOutletRebootDelay, systemConfigModifiedCount=systemConfigModifiedCount, systemTables=systemTables, towerTable=towerTable, towerEntry=towerEntry, towerIndex=towerIndex, towerID=towerID, towerName=towerName, towerStatus=towerStatus, towerInfeedCount=towerInfeedCount, towerProductSN=towerProductSN, towerModelNumber=towerModelNumber, towerCapabilities=towerCapabilities, towerVACapacity=towerVACapacity, towerVACapacityUsed=towerVACapacityUsed, towerActivePower=towerActivePower, towerApparentPower=towerApparentPower, towerPowerFactor=towerPowerFactor, towerEnergy=towerEnergy, towerLineFrequency=towerLineFrequency, infeedTable=infeedTable, infeedEntry=infeedEntry, infeedIndex=infeedIndex, infeedID=infeedID, infeedName=infeedName, infeedCapabilities=infeedCapabilities, infeedStatus=infeedStatus, infeedLoadStatus=infeedLoadStatus, infeedLoadValue=infeedLoadValue, infeedLoadHighThresh=infeedLoadHighThresh, infeedOutletCount=infeedOutletCount, infeedCapacity=infeedCapacity, infeedVoltage=infeedVoltage, infeedPower=infeedPower, infeedApparentPower=infeedApparentPower, infeedPowerFactor=infeedPowerFactor, infeedCrestFactor=infeedCrestFactor, infeedEnergy=infeedEnergy, infeedReactance=infeedReactance, infeedPhaseVoltage=infeedPhaseVoltage, infeedPhaseCurrent=infeedPhaseCurrent, infeedCapacityUsed=infeedCapacityUsed, infeedLineID=infeedLineID, infeedLineToLineID=infeedLineToLineID, infeedPhaseID=infeedPhaseID, infeedVACapacity=infeedVACapacity, infeedVACapacityUsed=infeedVACapacityUsed, outletTable=outletTable, outletEntry=outletEntry, outletIndex=outletIndex, outletID=outletID, outletName=outletName, outletCapabilities=outletCapabilities, outletStatus=outletStatus, outletLoadStatus=outletLoadStatus, outletLoadValue=outletLoadValue, outletLoadLowThresh=outletLoadLowThresh, outletLoadHighThresh=outletLoadHighThresh, outletControlState=outletControlState, outletControlAction=outletControlAction, outletCapacity=outletCapacity, outletVoltage=outletVoltage, outletPower=outletPower, outletApparentPower=outletApparentPower, outletPowerFactor=outletPowerFactor, outletCrestFactor=outletCrestFactor, outletEnergy=outletEnergy, outletWakeupState=outletWakeupState, outletPostOnDelay=outletPostOnDelay, envMonTable=envMonTable, envMonEntry=envMonEntry, envMonIndex=envMonIndex, envMonID=envMonID, envMonName=envMonName, envMonStatus=envMonStatus, envMonWaterSensorName=envMonWaterSensorName, envMonWaterSensorStatus=envMonWaterSensorStatus, envMonADCName=envMonADCName, envMonADCStatus=envMonADCStatus, envMonADCCount=envMonADCCount, envMonADCLowThresh=envMonADCLowThresh, envMonADCHighThresh=envMonADCHighThresh, envMonTempHumidSensorCount=envMonTempHumidSensorCount, envMonContactClosureCount=envMonContactClosureCount, tempHumidSensorTable=tempHumidSensorTable, tempHumidSensorEntry=tempHumidSensorEntry, tempHumidSensorIndex=tempHumidSensorIndex, tempHumidSensorID=tempHumidSensorID, tempHumidSensorName=tempHumidSensorName, tempHumidSensorStatus=tempHumidSensorStatus, tempHumidSensorTempStatus=tempHumidSensorTempStatus, tempHumidSensorTempValue=tempHumidSensorTempValue, tempHumidSensorTempLowThresh=tempHumidSensorTempLowThresh, tempHumidSensorTempHighThresh=tempHumidSensorTempHighThresh, tempHumidSensorHumidStatus=tempHumidSensorHumidStatus, tempHumidSensorHumidValue=tempHumidSensorHumidValue, tempHumidSensorHumidLowThresh=tempHumidSensorHumidLowThresh, tempHumidSensorHumidHighThresh=tempHumidSensorHumidHighThresh, tempHumidSensorTempScale=tempHumidSensorTempScale, tempHumidSensorTempRecDelta=tempHumidSensorTempRecDelta, tempHumidSensorHumidRecDelta=tempHumidSensorHumidRecDelta, contactClosureTable=contactClosureTable, contactClosureEntry=contactClosureEntry, contactClosureIndex=contactClosureIndex, contactClosureID=contactClosureID, contactClosureName=contactClosureName, contactClosureStatus=contactClosureStatus, branchTable=branchTable, branchEntry=branchEntry, branchIndex=branchIndex)
mibBuilder.exportSymbols("Sentry3", branchID=branchID, branchName=branchName, branchCapabilities=branchCapabilities, branchStatus=branchStatus, branchLoadStatus=branchLoadStatus, branchLoadValue=branchLoadValue, branchLoadHighThresh=branchLoadHighThresh, branchCapacity=branchCapacity, eventInformationGroup=eventInformationGroup, eventStatusText=eventStatusText, eventStatusCondition=eventStatusCondition, sentry3Traps=sentry3Traps, events=events)

# Notifications
mibBuilder.exportSymbols("Sentry3", towerStatusEvent=towerStatusEvent, infeedStatusEvent=infeedStatusEvent, infeedLoadEvent=infeedLoadEvent, outletStatusEvent=outletStatusEvent, outletLoadEvent=outletLoadEvent, outletChangeEvent=outletChangeEvent, envMonStatusEvent=envMonStatusEvent, envMonWaterSensorEvent=envMonWaterSensorEvent, envMonADCEvent=envMonADCEvent, tempHumidSensorStatusEvent=tempHumidSensorStatusEvent, tempHumidSensorTempEvent=tempHumidSensorTempEvent, tempHumidSensorHumidEvent=tempHumidSensorHumidEvent, contactClosureEvent=contactClosureEvent, branchStatusEvent=branchStatusEvent, branchLoadEvent=branchLoadEvent)

